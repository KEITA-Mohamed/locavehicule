"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_find-cache-dir_index_js"],{

/***/ "./node_modules/common-path-prefix/index.js":
/*!**************************************************!*\
  !*** ./node_modules/common-path-prefix/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


const { sep: DEFAULT_SEPARATOR } = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))

const determineSeparator = paths => {
  for (const path of paths) {
    const match = /(\/|\\)/.exec(path)
    if (match !== null) return match[0]
  }

  return DEFAULT_SEPARATOR
}

module.exports = function commonPathPrefix (paths, sep = determineSeparator(paths)) {
  const [first = '', ...remaining] = paths
  if (first === '' || remaining.length === 0) return ''

  const parts = first.split(sep)

  let endOfPrefix = parts.length
  for (const path of remaining) {
    const compare = path.split(sep)
    for (let i = 0; i < endOfPrefix; i++) {
      if (compare[i] !== parts[i]) {
        endOfPrefix = i
      }
    }

    if (endOfPrefix === 0) return ''
  }

  const prefix = parts.slice(0, endOfPrefix).join(sep)
  return prefix.endsWith(sep) ? prefix : prefix + sep
}


/***/ }),

/***/ "./node_modules/find-cache-dir/index.js":
/*!**********************************************!*\
  !*** ./node_modules/find-cache-dir/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ findCacheDirectory)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:fs */ "node:fs");
/* harmony import */ var common_path_prefix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common-path-prefix */ "./node_modules/common-path-prefix/index.js");
/* harmony import */ var pkg_dir__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pkg-dir */ "./node_modules/pkg-dir/index.js");






const {env, cwd} = node_process__WEBPACK_IMPORTED_MODULE_0__;

const isWritable = path => {
	try {
		node_fs__WEBPACK_IMPORTED_MODULE_2__.accessSync(path, node_fs__WEBPACK_IMPORTED_MODULE_2__.constants.W_OK);
		return true;
	} catch {
		return false;
	}
};

function useDirectory(directory, options) {
	if (options.create) {
		node_fs__WEBPACK_IMPORTED_MODULE_2__.mkdirSync(directory, {recursive: true});
	}

	if (options.thunk) {
		return (...arguments_) => node_path__WEBPACK_IMPORTED_MODULE_1__.join(directory, ...arguments_);
	}

	return directory;
}

function getNodeModuleDirectory(directory) {
	const nodeModules = node_path__WEBPACK_IMPORTED_MODULE_1__.join(directory, 'node_modules');

	if (
		!isWritable(nodeModules)
			&& (node_fs__WEBPACK_IMPORTED_MODULE_2__.existsSync(nodeModules) || !isWritable(node_path__WEBPACK_IMPORTED_MODULE_1__.join(directory)))
	) {
		return;
	}

	return nodeModules;
}

function findCacheDirectory(options = {}) {
	if (env.CACHE_DIR && !['true', 'false', '1', '0'].includes(env.CACHE_DIR)) {
		return useDirectory(node_path__WEBPACK_IMPORTED_MODULE_1__.join(env.CACHE_DIR, options.name), options);
	}

	let {cwd: directory = cwd()} = options;

	if (options.files) {
		directory = common_path_prefix__WEBPACK_IMPORTED_MODULE_3__(options.files.map(file => node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(directory, file)));
	}

	directory = (0,pkg_dir__WEBPACK_IMPORTED_MODULE_4__.packageDirectorySync)({cwd: directory});

	if (!directory) {
		return;
	}

	const nodeModules = getNodeModuleDirectory(directory);
	if (!nodeModules) {
		return;
	}

	return useDirectory(node_path__WEBPACK_IMPORTED_MODULE_1__.join(directory, 'node_modules', '.cache', options.name), options);
}


/***/ }),

/***/ "./node_modules/find-up/index.js":
/*!***************************************!*\
  !*** ./node_modules/find-up/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findUp: () => (/* binding */ findUp),
/* harmony export */   findUpMultiple: () => (/* binding */ findUpMultiple),
/* harmony export */   findUpMultipleSync: () => (/* binding */ findUpMultipleSync),
/* harmony export */   findUpStop: () => (/* binding */ findUpStop),
/* harmony export */   findUpSync: () => (/* binding */ findUpSync),
/* harmony export */   pathExists: () => (/* reexport safe */ path_exists__WEBPACK_IMPORTED_MODULE_3__.pathExists),
/* harmony export */   pathExistsSync: () => (/* reexport safe */ path_exists__WEBPACK_IMPORTED_MODULE_3__.pathExistsSync)
/* harmony export */ });
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var locate_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! locate-path */ "./node_modules/locate-path/index.js");
/* harmony import */ var path_exists__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path-exists */ "./node_modules/path-exists/index.js");




const toPath = urlOrPath => urlOrPath instanceof URL ? (0,node_url__WEBPACK_IMPORTED_MODULE_1__.fileURLToPath)(urlOrPath) : urlOrPath;

const findUpStop = Symbol('findUpStop');

async function findUpMultiple(name, options = {}) {
	let directory = node_path__WEBPACK_IMPORTED_MODULE_0__.resolve(toPath(options.cwd) || '');
	const {root} = node_path__WEBPACK_IMPORTED_MODULE_0__.parse(directory);
	const stopAt = node_path__WEBPACK_IMPORTED_MODULE_0__.resolve(directory, options.stopAt || root);
	const limit = options.limit || Number.POSITIVE_INFINITY;
	const paths = [name].flat();

	const runMatcher = async locateOptions => {
		if (typeof name !== 'function') {
			return (0,locate_path__WEBPACK_IMPORTED_MODULE_2__.locatePath)(paths, locateOptions);
		}

		const foundPath = await name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return (0,locate_path__WEBPACK_IMPORTED_MODULE_2__.locatePath)([foundPath], locateOptions);
		}

		return foundPath;
	};

	const matches = [];
	// eslint-disable-next-line no-constant-condition
	while (true) {
		// eslint-disable-next-line no-await-in-loop
		const foundPath = await runMatcher({...options, cwd: directory});

		if (foundPath === findUpStop) {
			break;
		}

		if (foundPath) {
			matches.push(node_path__WEBPACK_IMPORTED_MODULE_0__.resolve(directory, foundPath));
		}

		if (directory === stopAt || matches.length >= limit) {
			break;
		}

		directory = node_path__WEBPACK_IMPORTED_MODULE_0__.dirname(directory);
	}

	return matches;
}

function findUpMultipleSync(name, options = {}) {
	let directory = node_path__WEBPACK_IMPORTED_MODULE_0__.resolve(toPath(options.cwd) || '');
	const {root} = node_path__WEBPACK_IMPORTED_MODULE_0__.parse(directory);
	const stopAt = options.stopAt || root;
	const limit = options.limit || Number.POSITIVE_INFINITY;
	const paths = [name].flat();

	const runMatcher = locateOptions => {
		if (typeof name !== 'function') {
			return (0,locate_path__WEBPACK_IMPORTED_MODULE_2__.locatePathSync)(paths, locateOptions);
		}

		const foundPath = name(locateOptions.cwd);
		if (typeof foundPath === 'string') {
			return (0,locate_path__WEBPACK_IMPORTED_MODULE_2__.locatePathSync)([foundPath], locateOptions);
		}

		return foundPath;
	};

	const matches = [];
	// eslint-disable-next-line no-constant-condition
	while (true) {
		const foundPath = runMatcher({...options, cwd: directory});

		if (foundPath === findUpStop) {
			break;
		}

		if (foundPath) {
			matches.push(node_path__WEBPACK_IMPORTED_MODULE_0__.resolve(directory, foundPath));
		}

		if (directory === stopAt || matches.length >= limit) {
			break;
		}

		directory = node_path__WEBPACK_IMPORTED_MODULE_0__.dirname(directory);
	}

	return matches;
}

async function findUp(name, options = {}) {
	const matches = await findUpMultiple(name, {...options, limit: 1});
	return matches[0];
}

function findUpSync(name, options = {}) {
	const matches = findUpMultipleSync(name, {...options, limit: 1});
	return matches[0];
}




/***/ }),

/***/ "./node_modules/locate-path/index.js":
/*!*******************************************!*\
  !*** ./node_modules/locate-path/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   locatePath: () => (/* binding */ locatePath),
/* harmony export */   locatePathSync: () => (/* binding */ locatePathSync)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:fs */ "node:fs");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var p_locate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! p-locate */ "./node_modules/p-locate/index.js");






const typeMappings = {
	directory: 'isDirectory',
	file: 'isFile',
};

function checkType(type) {
	if (Object.hasOwnProperty.call(typeMappings, type)) {
		return;
	}

	throw new Error(`Invalid type specified: ${type}`);
}

const matchType = (type, stat) => stat[typeMappings[type]]();

const toPath = urlOrPath => urlOrPath instanceof URL ? (0,node_url__WEBPACK_IMPORTED_MODULE_3__.fileURLToPath)(urlOrPath) : urlOrPath;

async function locatePath(
	paths,
	{
		cwd = node_process__WEBPACK_IMPORTED_MODULE_0__.cwd(),
		type = 'file',
		allowSymlinks = true,
		concurrency,
		preserveOrder,
	} = {},
) {
	checkType(type);
	cwd = toPath(cwd);

	const statFunction = allowSymlinks ? node_fs__WEBPACK_IMPORTED_MODULE_2__.promises.stat : node_fs__WEBPACK_IMPORTED_MODULE_2__.promises.lstat;

	return (0,p_locate__WEBPACK_IMPORTED_MODULE_4__["default"])(paths, async path_ => {
		try {
			const stat = await statFunction(node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(cwd, path_));
			return matchType(type, stat);
		} catch {
			return false;
		}
	}, {concurrency, preserveOrder});
}

function locatePathSync(
	paths,
	{
		cwd = node_process__WEBPACK_IMPORTED_MODULE_0__.cwd(),
		type = 'file',
		allowSymlinks = true,
	} = {},
) {
	checkType(type);
	cwd = toPath(cwd);

	const statFunction = allowSymlinks ? node_fs__WEBPACK_IMPORTED_MODULE_2__.statSync : node_fs__WEBPACK_IMPORTED_MODULE_2__.lstatSync;

	for (const path_ of paths) {
		try {
			const stat = statFunction(node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(cwd, path_), {
				throwIfNoEntry: false,
			});

			if (!stat) {
				continue;
			}

			if (matchType(type, stat)) {
				return path_;
			}
		} catch {}
	}
}


/***/ }),

/***/ "./node_modules/p-limit/index.js":
/*!***************************************!*\
  !*** ./node_modules/p-limit/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pLimit)
/* harmony export */ });
/* harmony import */ var yocto_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yocto-queue */ "./node_modules/yocto-queue/index.js");


function pLimit(concurrency) {
	if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = new yocto_queue__WEBPACK_IMPORTED_MODULE_0__["default"]();
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.size > 0) {
			queue.dequeue()();
		}
	};

	const run = async (fn, resolve, args) => {
		activeCount++;

		const result = (async () => fn(...args))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (fn, resolve, args) => {
		queue.enqueue(run.bind(undefined, fn, resolve, args));

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// when the run function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency && queue.size > 0) {
				queue.dequeue()();
			}
		})();
	};

	const generator = (fn, ...args) => new Promise(resolve => {
		enqueue(fn, resolve, args);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount,
		},
		pendingCount: {
			get: () => queue.size,
		},
		clearQueue: {
			value: () => {
				queue.clear();
			},
		},
	});

	return generator;
}


/***/ }),

/***/ "./node_modules/p-locate/index.js":
/*!****************************************!*\
  !*** ./node_modules/p-locate/index.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pLocate)
/* harmony export */ });
/* harmony import */ var p_limit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-limit */ "./node_modules/p-limit/index.js");


class EndError extends Error {
	constructor(value) {
		super();
		this.value = value;
	}
}

// The input can also be a promise, so we await it.
const testElement = async (element, tester) => tester(await element);

// The input can also be a promise, so we `Promise.all()` them both.
const finder = async element => {
	const values = await Promise.all(element);
	if (values[1] === true) {
		throw new EndError(values[0]);
	}

	return false;
};

async function pLocate(
	iterable,
	tester,
	{
		concurrency = Number.POSITIVE_INFINITY,
		preserveOrder = true,
	} = {},
) {
	const limit = (0,p_limit__WEBPACK_IMPORTED_MODULE_0__["default"])(concurrency);

	// Start all the promises concurrently with optional limit.
	const items = [...iterable].map(element => [element, limit(testElement, element, tester)]);

	// Check the promises either serially or concurrently.
	const checkLimit = (0,p_limit__WEBPACK_IMPORTED_MODULE_0__["default"])(preserveOrder ? 1 : Number.POSITIVE_INFINITY);

	try {
		await Promise.all(items.map(element => checkLimit(finder, element)));
	} catch (error) {
		if (error instanceof EndError) {
			return error.value;
		}

		throw error;
	}
}


/***/ }),

/***/ "./node_modules/path-exists/index.js":
/*!*******************************************!*\
  !*** ./node_modules/path-exists/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pathExists: () => (/* binding */ pathExists),
/* harmony export */   pathExistsSync: () => (/* binding */ pathExistsSync)
/* harmony export */ });
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ "node:fs");


async function pathExists(path) {
	try {
		await node_fs__WEBPACK_IMPORTED_MODULE_0__.promises.access(path);
		return true;
	} catch {
		return false;
	}
}

function pathExistsSync(path) {
	try {
		node_fs__WEBPACK_IMPORTED_MODULE_0__.accessSync(path);
		return true;
	} catch {
		return false;
	}
}


/***/ }),

/***/ "./node_modules/pkg-dir/index.js":
/*!***************************************!*\
  !*** ./node_modules/pkg-dir/index.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   packageDirectory: () => (/* binding */ packageDirectory),
/* harmony export */   packageDirectorySync: () => (/* binding */ packageDirectorySync)
/* harmony export */ });
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var find_up__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! find-up */ "./node_modules/find-up/index.js");



async function packageDirectory({cwd} = {}) {
	const filePath = await (0,find_up__WEBPACK_IMPORTED_MODULE_1__.findUp)('package.json', {cwd});
	return filePath && node_path__WEBPACK_IMPORTED_MODULE_0__.dirname(filePath);
}

function packageDirectorySync({cwd} = {}) {
	const filePath = (0,find_up__WEBPACK_IMPORTED_MODULE_1__.findUpSync)('package.json', {cwd});
	return filePath && node_path__WEBPACK_IMPORTED_MODULE_0__.dirname(filePath);
}


/***/ }),

/***/ "./node_modules/yocto-queue/index.js":
/*!*******************************************!*\
  !*** ./node_modules/yocto-queue/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Queue)
/* harmony export */ });
/*
How it works:
`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
*/

class Node {
	value;
	next;

	constructor(value) {
		this.value = value;
	}
}

class Queue {
	#head;
	#tail;
	#size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this.#head) {
			this.#tail.next = node;
			this.#tail = node;
		} else {
			this.#head = node;
			this.#tail = node;
		}

		this.#size++;
	}

	dequeue() {
		const current = this.#head;
		if (!current) {
			return;
		}

		this.#head = this.#head.next;
		this.#size--;
		return current.value;
	}

	clear() {
		this.#head = undefined;
		this.#tail = undefined;
		this.#size = 0;
	}

	get size() {
		return this.#size;
	}

	* [Symbol.iterator]() {
		let current = this.#head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZmluZC1jYWNoZS1kaXJfaW5kZXhfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQVk7QUFDWixRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsbUlBQU07O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ21DO0FBQ047QUFDSjtBQUN5QjtBQUNMOztBQUU3QyxPQUFPLFVBQVUsRUFBRSx5Q0FBTzs7QUFFMUI7QUFDQTtBQUNBLEVBQUUsK0NBQWEsT0FBTyw4Q0FBWTtBQUNsQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsOENBQVksYUFBYSxnQkFBZ0I7QUFDM0M7O0FBRUE7QUFDQSw0QkFBNEIsMkNBQVM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiwyQ0FBUzs7QUFFOUI7QUFDQTtBQUNBLE9BQU8sK0NBQWEsNkJBQTZCLDJDQUFTO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVlLHdDQUF3QztBQUN2RDtBQUNBLHNCQUFzQiwyQ0FBUztBQUMvQjs7QUFFQSxNQUFNLHdCQUF3Qjs7QUFFOUI7QUFDQSxjQUFjLCtDQUFnQiwyQkFBMkIsOENBQVk7QUFDckU7O0FBRUEsYUFBYSw2REFBb0IsRUFBRSxlQUFlOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDJDQUFTO0FBQzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakU2QjtBQUNVO0FBQ2dCOztBQUV2RCx1REFBdUQsdURBQWE7O0FBRTdEOztBQUVBLGdEQUFnRDtBQUN2RCxpQkFBaUIsOENBQVk7QUFD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O0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQ21EOztBQUU1QztBQUNQO0FBQ0EsUUFBUSw2Q0FBVTtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLEVBQUUsK0NBQWE7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xCNkI7QUFDYzs7QUFFcEMsaUNBQWlDLEtBQUssSUFBSTtBQUNqRCx3QkFBd0IsK0NBQU0sa0JBQWtCLElBQUk7QUFDcEQsb0JBQW9CLDhDQUFZO0FBQ2hDOztBQUVPLCtCQUErQixLQUFLLElBQUk7QUFDL0Msa0JBQWtCLG1EQUFVLGtCQUFrQixJQUFJO0FBQ2xELG9CQUFvQiw4Q0FBWTtBQUNoQzs7Ozs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbW1vbi1wYXRoLXByZWZpeC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmluZC1jYWNoZS1kaXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbmQtdXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvY2F0ZS1wYXRoL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wLWxpbWl0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wLWxvY2F0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1leGlzdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BrZy1kaXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3lvY3RvLXF1ZXVlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBzZXA6IERFRkFVTFRfU0VQQVJBVE9SIH0gPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgZGV0ZXJtaW5lU2VwYXJhdG9yID0gcGF0aHMgPT4ge1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBtYXRjaCA9IC8oXFwvfFxcXFwpLy5leGVjKHBhdGgpXG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSByZXR1cm4gbWF0Y2hbMF1cbiAgfVxuXG4gIHJldHVybiBERUZBVUxUX1NFUEFSQVRPUlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbW1vblBhdGhQcmVmaXggKHBhdGhzLCBzZXAgPSBkZXRlcm1pbmVTZXBhcmF0b3IocGF0aHMpKSB7XG4gIGNvbnN0IFtmaXJzdCA9ICcnLCAuLi5yZW1haW5pbmddID0gcGF0aHNcbiAgaWYgKGZpcnN0ID09PSAnJyB8fCByZW1haW5pbmcubGVuZ3RoID09PSAwKSByZXR1cm4gJydcblxuICBjb25zdCBwYXJ0cyA9IGZpcnN0LnNwbGl0KHNlcClcblxuICBsZXQgZW5kT2ZQcmVmaXggPSBwYXJ0cy5sZW5ndGhcbiAgZm9yIChjb25zdCBwYXRoIG9mIHJlbWFpbmluZykge1xuICAgIGNvbnN0IGNvbXBhcmUgPSBwYXRoLnNwbGl0KHNlcClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZE9mUHJlZml4OyBpKyspIHtcbiAgICAgIGlmIChjb21wYXJlW2ldICE9PSBwYXJ0c1tpXSkge1xuICAgICAgICBlbmRPZlByZWZpeCA9IGlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kT2ZQcmVmaXggPT09IDApIHJldHVybiAnJ1xuICB9XG5cbiAgY29uc3QgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgZW5kT2ZQcmVmaXgpLmpvaW4oc2VwKVxuICByZXR1cm4gcHJlZml4LmVuZHNXaXRoKHNlcCkgPyBwcmVmaXggOiBwcmVmaXggKyBzZXBcbn1cbiIsImltcG9ydCBwcm9jZXNzIGZyb20gJ25vZGU6cHJvY2Vzcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IGZzIGZyb20gJ25vZGU6ZnMnO1xuaW1wb3J0IGNvbW1vblBhdGhQcmVmaXggZnJvbSAnY29tbW9uLXBhdGgtcHJlZml4JztcbmltcG9ydCB7cGFja2FnZURpcmVjdG9yeVN5bmN9IGZyb20gJ3BrZy1kaXInO1xuXG5jb25zdCB7ZW52LCBjd2R9ID0gcHJvY2VzcztcblxuY29uc3QgaXNXcml0YWJsZSA9IHBhdGggPT4ge1xuXHR0cnkge1xuXHRcdGZzLmFjY2Vzc1N5bmMocGF0aCwgZnMuY29uc3RhbnRzLldfT0spO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIHVzZURpcmVjdG9yeShkaXJlY3RvcnksIG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMuY3JlYXRlKSB7XG5cdFx0ZnMubWtkaXJTeW5jKGRpcmVjdG9yeSwge3JlY3Vyc2l2ZTogdHJ1ZX0pO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMudGh1bmspIHtcblx0XHRyZXR1cm4gKC4uLmFyZ3VtZW50c18pID0+IHBhdGguam9pbihkaXJlY3RvcnksIC4uLmFyZ3VtZW50c18pO1xuXHR9XG5cblx0cmV0dXJuIGRpcmVjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZU1vZHVsZURpcmVjdG9yeShkaXJlY3RvcnkpIHtcblx0Y29uc3Qgbm9kZU1vZHVsZXMgPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCAnbm9kZV9tb2R1bGVzJyk7XG5cblx0aWYgKFxuXHRcdCFpc1dyaXRhYmxlKG5vZGVNb2R1bGVzKVxuXHRcdFx0JiYgKGZzLmV4aXN0c1N5bmMobm9kZU1vZHVsZXMpIHx8ICFpc1dyaXRhYmxlKHBhdGguam9pbihkaXJlY3RvcnkpKSlcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0cmV0dXJuIG5vZGVNb2R1bGVzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kQ2FjaGVEaXJlY3Rvcnkob3B0aW9ucyA9IHt9KSB7XG5cdGlmIChlbnYuQ0FDSEVfRElSICYmICFbJ3RydWUnLCAnZmFsc2UnLCAnMScsICcwJ10uaW5jbHVkZXMoZW52LkNBQ0hFX0RJUikpIHtcblx0XHRyZXR1cm4gdXNlRGlyZWN0b3J5KHBhdGguam9pbihlbnYuQ0FDSEVfRElSLCBvcHRpb25zLm5hbWUpLCBvcHRpb25zKTtcblx0fVxuXG5cdGxldCB7Y3dkOiBkaXJlY3RvcnkgPSBjd2QoKX0gPSBvcHRpb25zO1xuXG5cdGlmIChvcHRpb25zLmZpbGVzKSB7XG5cdFx0ZGlyZWN0b3J5ID0gY29tbW9uUGF0aFByZWZpeChvcHRpb25zLmZpbGVzLm1hcChmaWxlID0+IHBhdGgucmVzb2x2ZShkaXJlY3RvcnksIGZpbGUpKSk7XG5cdH1cblxuXHRkaXJlY3RvcnkgPSBwYWNrYWdlRGlyZWN0b3J5U3luYyh7Y3dkOiBkaXJlY3Rvcnl9KTtcblxuXHRpZiAoIWRpcmVjdG9yeSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IG5vZGVNb2R1bGVzID0gZ2V0Tm9kZU1vZHVsZURpcmVjdG9yeShkaXJlY3RvcnkpO1xuXHRpZiAoIW5vZGVNb2R1bGVzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0cmV0dXJuIHVzZURpcmVjdG9yeShwYXRoLmpvaW4oZGlyZWN0b3J5LCAnbm9kZV9tb2R1bGVzJywgJy5jYWNoZScsIG9wdGlvbnMubmFtZSksIG9wdGlvbnMpO1xufVxuIiwiaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB7ZmlsZVVSTFRvUGF0aH0gZnJvbSAnbm9kZTp1cmwnO1xuaW1wb3J0IHtsb2NhdGVQYXRoLCBsb2NhdGVQYXRoU3luY30gZnJvbSAnbG9jYXRlLXBhdGgnO1xuXG5jb25zdCB0b1BhdGggPSB1cmxPclBhdGggPT4gdXJsT3JQYXRoIGluc3RhbmNlb2YgVVJMID8gZmlsZVVSTFRvUGF0aCh1cmxPclBhdGgpIDogdXJsT3JQYXRoO1xuXG5leHBvcnQgY29uc3QgZmluZFVwU3RvcCA9IFN5bWJvbCgnZmluZFVwU3RvcCcpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZFVwTXVsdGlwbGUobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cdGxldCBkaXJlY3RvcnkgPSBwYXRoLnJlc29sdmUodG9QYXRoKG9wdGlvbnMuY3dkKSB8fCAnJyk7XG5cdGNvbnN0IHtyb290fSA9IHBhdGgucGFyc2UoZGlyZWN0b3J5KTtcblx0Y29uc3Qgc3RvcEF0ID0gcGF0aC5yZXNvbHZlKGRpcmVjdG9yeSwgb3B0aW9ucy5zdG9wQXQgfHwgcm9vdCk7XG5cdGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdGNvbnN0IHBhdGhzID0gW25hbWVdLmZsYXQoKTtcblxuXHRjb25zdCBydW5NYXRjaGVyID0gYXN5bmMgbG9jYXRlT3B0aW9ucyA9PiB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbG9jYXRlUGF0aChwYXRocywgbG9jYXRlT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZm91bmRQYXRoID0gYXdhaXQgbmFtZShsb2NhdGVPcHRpb25zLmN3ZCk7XG5cdFx0aWYgKHR5cGVvZiBmb3VuZFBhdGggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbG9jYXRlUGF0aChbZm91bmRQYXRoXSwgbG9jYXRlT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvdW5kUGF0aDtcblx0fTtcblxuXHRjb25zdCBtYXRjaGVzID0gW107XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblx0d2hpbGUgKHRydWUpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxuXHRcdGNvbnN0IGZvdW5kUGF0aCA9IGF3YWl0IHJ1bk1hdGNoZXIoey4uLm9wdGlvbnMsIGN3ZDogZGlyZWN0b3J5fSk7XG5cblx0XHRpZiAoZm91bmRQYXRoID09PSBmaW5kVXBTdG9wKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRpZiAoZm91bmRQYXRoKSB7XG5cdFx0XHRtYXRjaGVzLnB1c2gocGF0aC5yZXNvbHZlKGRpcmVjdG9yeSwgZm91bmRQYXRoKSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRpcmVjdG9yeSA9PT0gc3RvcEF0IHx8IG1hdGNoZXMubGVuZ3RoID49IGxpbWl0KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRkaXJlY3RvcnkgPSBwYXRoLmRpcm5hbWUoZGlyZWN0b3J5KTtcblx0fVxuXG5cdHJldHVybiBtYXRjaGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFVwTXVsdGlwbGVTeW5jKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuXHRsZXQgZGlyZWN0b3J5ID0gcGF0aC5yZXNvbHZlKHRvUGF0aChvcHRpb25zLmN3ZCkgfHwgJycpO1xuXHRjb25zdCB7cm9vdH0gPSBwYXRoLnBhcnNlKGRpcmVjdG9yeSk7XG5cdGNvbnN0IHN0b3BBdCA9IG9wdGlvbnMuc3RvcEF0IHx8IHJvb3Q7XG5cdGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdGNvbnN0IHBhdGhzID0gW25hbWVdLmZsYXQoKTtcblxuXHRjb25zdCBydW5NYXRjaGVyID0gbG9jYXRlT3B0aW9ucyA9PiB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbG9jYXRlUGF0aFN5bmMocGF0aHMsIGxvY2F0ZU9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGZvdW5kUGF0aCA9IG5hbWUobG9jYXRlT3B0aW9ucy5jd2QpO1xuXHRcdGlmICh0eXBlb2YgZm91bmRQYXRoID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGxvY2F0ZVBhdGhTeW5jKFtmb3VuZFBhdGhdLCBsb2NhdGVPcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm91bmRQYXRoO1xuXHR9O1xuXG5cdGNvbnN0IG1hdGNoZXMgPSBbXTtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGNvbnN0IGZvdW5kUGF0aCA9IHJ1bk1hdGNoZXIoey4uLm9wdGlvbnMsIGN3ZDogZGlyZWN0b3J5fSk7XG5cblx0XHRpZiAoZm91bmRQYXRoID09PSBmaW5kVXBTdG9wKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRpZiAoZm91bmRQYXRoKSB7XG5cdFx0XHRtYXRjaGVzLnB1c2gocGF0aC5yZXNvbHZlKGRpcmVjdG9yeSwgZm91bmRQYXRoKSk7XG5cdFx0fVxuXG5cdFx0aWYgKGRpcmVjdG9yeSA9PT0gc3RvcEF0IHx8IG1hdGNoZXMubGVuZ3RoID49IGxpbWl0KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRkaXJlY3RvcnkgPSBwYXRoLmRpcm5hbWUoZGlyZWN0b3J5KTtcblx0fVxuXG5cdHJldHVybiBtYXRjaGVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZFVwKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuXHRjb25zdCBtYXRjaGVzID0gYXdhaXQgZmluZFVwTXVsdGlwbGUobmFtZSwgey4uLm9wdGlvbnMsIGxpbWl0OiAxfSk7XG5cdHJldHVybiBtYXRjaGVzWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFVwU3luYyhuYW1lLCBvcHRpb25zID0ge30pIHtcblx0Y29uc3QgbWF0Y2hlcyA9IGZpbmRVcE11bHRpcGxlU3luYyhuYW1lLCB7Li4ub3B0aW9ucywgbGltaXQ6IDF9KTtcblx0cmV0dXJuIG1hdGNoZXNbMF07XG59XG5cbmV4cG9ydCB7XG5cdHBhdGhFeGlzdHMsXG5cdHBhdGhFeGlzdHNTeW5jLFxufSBmcm9tICdwYXRoLWV4aXN0cyc7XG4iLCJpbXBvcnQgcHJvY2VzcyBmcm9tICdub2RlOnByb2Nlc3MnO1xuaW1wb3J0IHBhdGggZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCBmcywge3Byb21pc2VzIGFzIGZzUHJvbWlzZXN9IGZyb20gJ25vZGU6ZnMnO1xuaW1wb3J0IHtmaWxlVVJMVG9QYXRofSBmcm9tICdub2RlOnVybCc7XG5pbXBvcnQgcExvY2F0ZSBmcm9tICdwLWxvY2F0ZSc7XG5cbmNvbnN0IHR5cGVNYXBwaW5ncyA9IHtcblx0ZGlyZWN0b3J5OiAnaXNEaXJlY3RvcnknLFxuXHRmaWxlOiAnaXNGaWxlJyxcbn07XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZSh0eXBlKSB7XG5cdGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlTWFwcGluZ3MsIHR5cGUpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR5cGUgc3BlY2lmaWVkOiAke3R5cGV9YCk7XG59XG5cbmNvbnN0IG1hdGNoVHlwZSA9ICh0eXBlLCBzdGF0KSA9PiBzdGF0W3R5cGVNYXBwaW5nc1t0eXBlXV0oKTtcblxuY29uc3QgdG9QYXRoID0gdXJsT3JQYXRoID0+IHVybE9yUGF0aCBpbnN0YW5jZW9mIFVSTCA/IGZpbGVVUkxUb1BhdGgodXJsT3JQYXRoKSA6IHVybE9yUGF0aDtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvY2F0ZVBhdGgoXG5cdHBhdGhzLFxuXHR7XG5cdFx0Y3dkID0gcHJvY2Vzcy5jd2QoKSxcblx0XHR0eXBlID0gJ2ZpbGUnLFxuXHRcdGFsbG93U3ltbGlua3MgPSB0cnVlLFxuXHRcdGNvbmN1cnJlbmN5LFxuXHRcdHByZXNlcnZlT3JkZXIsXG5cdH0gPSB7fSxcbikge1xuXHRjaGVja1R5cGUodHlwZSk7XG5cdGN3ZCA9IHRvUGF0aChjd2QpO1xuXG5cdGNvbnN0IHN0YXRGdW5jdGlvbiA9IGFsbG93U3ltbGlua3MgPyBmc1Byb21pc2VzLnN0YXQgOiBmc1Byb21pc2VzLmxzdGF0O1xuXG5cdHJldHVybiBwTG9jYXRlKHBhdGhzLCBhc3luYyBwYXRoXyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0RnVuY3Rpb24ocGF0aC5yZXNvbHZlKGN3ZCwgcGF0aF8pKTtcblx0XHRcdHJldHVybiBtYXRjaFR5cGUodHlwZSwgc3RhdCk7XG5cdFx0fSBjYXRjaCB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9LCB7Y29uY3VycmVuY3ksIHByZXNlcnZlT3JkZXJ9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2F0ZVBhdGhTeW5jKFxuXHRwYXRocyxcblx0e1xuXHRcdGN3ZCA9IHByb2Nlc3MuY3dkKCksXG5cdFx0dHlwZSA9ICdmaWxlJyxcblx0XHRhbGxvd1N5bWxpbmtzID0gdHJ1ZSxcblx0fSA9IHt9LFxuKSB7XG5cdGNoZWNrVHlwZSh0eXBlKTtcblx0Y3dkID0gdG9QYXRoKGN3ZCk7XG5cblx0Y29uc3Qgc3RhdEZ1bmN0aW9uID0gYWxsb3dTeW1saW5rcyA/IGZzLnN0YXRTeW5jIDogZnMubHN0YXRTeW5jO1xuXG5cdGZvciAoY29uc3QgcGF0aF8gb2YgcGF0aHMpIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgc3RhdCA9IHN0YXRGdW5jdGlvbihwYXRoLnJlc29sdmUoY3dkLCBwYXRoXyksIHtcblx0XHRcdFx0dGhyb3dJZk5vRW50cnk6IGZhbHNlLFxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghc3RhdCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hdGNoVHlwZSh0eXBlLCBzdGF0KSkge1xuXHRcdFx0XHRyZXR1cm4gcGF0aF87XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCB7fVxuXHR9XG59XG4iLCJpbXBvcnQgUXVldWUgZnJvbSAneW9jdG8tcXVldWUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwTGltaXQoY29uY3VycmVuY3kpIHtcblx0aWYgKCEoKE51bWJlci5pc0ludGVnZXIoY29uY3VycmVuY3kpIHx8IGNvbmN1cnJlbmN5ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpICYmIGNvbmN1cnJlbmN5ID4gMCkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgY29uY3VycmVuY3lgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAnKTtcblx0fVxuXG5cdGNvbnN0IHF1ZXVlID0gbmV3IFF1ZXVlKCk7XG5cdGxldCBhY3RpdmVDb3VudCA9IDA7XG5cblx0Y29uc3QgbmV4dCA9ICgpID0+IHtcblx0XHRhY3RpdmVDb3VudC0tO1xuXG5cdFx0aWYgKHF1ZXVlLnNpemUgPiAwKSB7XG5cdFx0XHRxdWV1ZS5kZXF1ZXVlKCkoKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgcnVuID0gYXN5bmMgKGZuLCByZXNvbHZlLCBhcmdzKSA9PiB7XG5cdFx0YWN0aXZlQ291bnQrKztcblxuXHRcdGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiBmbiguLi5hcmdzKSkoKTtcblxuXHRcdHJlc29sdmUocmVzdWx0KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCByZXN1bHQ7XG5cdFx0fSBjYXRjaCB7fVxuXG5cdFx0bmV4dCgpO1xuXHR9O1xuXG5cdGNvbnN0IGVucXVldWUgPSAoZm4sIHJlc29sdmUsIGFyZ3MpID0+IHtcblx0XHRxdWV1ZS5lbnF1ZXVlKHJ1bi5iaW5kKHVuZGVmaW5lZCwgZm4sIHJlc29sdmUsIGFyZ3MpKTtcblxuXHRcdChhc3luYyAoKSA9PiB7XG5cdFx0XHQvLyBUaGlzIGZ1bmN0aW9uIG5lZWRzIHRvIHdhaXQgdW50aWwgdGhlIG5leHQgbWljcm90YXNrIGJlZm9yZSBjb21wYXJpbmdcblx0XHRcdC8vIGBhY3RpdmVDb3VudGAgdG8gYGNvbmN1cnJlbmN5YCwgYmVjYXVzZSBgYWN0aXZlQ291bnRgIGlzIHVwZGF0ZWQgYXN5bmNocm9ub3VzbHlcblx0XHRcdC8vIHdoZW4gdGhlIHJ1biBmdW5jdGlvbiBpcyBkZXF1ZXVlZCBhbmQgY2FsbGVkLiBUaGUgY29tcGFyaXNvbiBpbiB0aGUgaWYtc3RhdGVtZW50XG5cdFx0XHQvLyBuZWVkcyB0byBoYXBwZW4gYXN5bmNocm9ub3VzbHkgYXMgd2VsbCB0byBnZXQgYW4gdXAtdG8tZGF0ZSB2YWx1ZSBmb3IgYGFjdGl2ZUNvdW50YC5cblx0XHRcdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdFx0XHRpZiAoYWN0aXZlQ291bnQgPCBjb25jdXJyZW5jeSAmJiBxdWV1ZS5zaXplID4gMCkge1xuXHRcdFx0XHRxdWV1ZS5kZXF1ZXVlKCkoKTtcblx0XHRcdH1cblx0XHR9KSgpO1xuXHR9O1xuXG5cdGNvbnN0IGdlbmVyYXRvciA9IChmbiwgLi4uYXJncykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0ZW5xdWV1ZShmbiwgcmVzb2x2ZSwgYXJncyk7XG5cdH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdlbmVyYXRvciwge1xuXHRcdGFjdGl2ZUNvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IGFjdGl2ZUNvdW50LFxuXHRcdH0sXG5cdFx0cGVuZGluZ0NvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IHF1ZXVlLnNpemUsXG5cdFx0fSxcblx0XHRjbGVhclF1ZXVlOiB7XG5cdFx0XHR2YWx1ZTogKCkgPT4ge1xuXHRcdFx0XHRxdWV1ZS5jbGVhcigpO1xuXHRcdFx0fSxcblx0XHR9LFxuXHR9KTtcblxuXHRyZXR1cm4gZ2VuZXJhdG9yO1xufVxuIiwiaW1wb3J0IHBMaW1pdCBmcm9tICdwLWxpbWl0JztcblxuY2xhc3MgRW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdH1cbn1cblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYXdhaXQgaXQuXG5jb25zdCB0ZXN0RWxlbWVudCA9IGFzeW5jIChlbGVtZW50LCB0ZXN0ZXIpID0+IHRlc3Rlcihhd2FpdCBlbGVtZW50KTtcblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYFByb21pc2UuYWxsKClgIHRoZW0gYm90aC5cbmNvbnN0IGZpbmRlciA9IGFzeW5jIGVsZW1lbnQgPT4ge1xuXHRjb25zdCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChlbGVtZW50KTtcblx0aWYgKHZhbHVlc1sxXSA9PT0gdHJ1ZSkge1xuXHRcdHRocm93IG5ldyBFbmRFcnJvcih2YWx1ZXNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcExvY2F0ZShcblx0aXRlcmFibGUsXG5cdHRlc3Rlcixcblx0e1xuXHRcdGNvbmN1cnJlbmN5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXHRcdHByZXNlcnZlT3JkZXIgPSB0cnVlLFxuXHR9ID0ge30sXG4pIHtcblx0Y29uc3QgbGltaXQgPSBwTGltaXQoY29uY3VycmVuY3kpO1xuXG5cdC8vIFN0YXJ0IGFsbCB0aGUgcHJvbWlzZXMgY29uY3VycmVudGx5IHdpdGggb3B0aW9uYWwgbGltaXQuXG5cdGNvbnN0IGl0ZW1zID0gWy4uLml0ZXJhYmxlXS5tYXAoZWxlbWVudCA9PiBbZWxlbWVudCwgbGltaXQodGVzdEVsZW1lbnQsIGVsZW1lbnQsIHRlc3RlcildKTtcblxuXHQvLyBDaGVjayB0aGUgcHJvbWlzZXMgZWl0aGVyIHNlcmlhbGx5IG9yIGNvbmN1cnJlbnRseS5cblx0Y29uc3QgY2hlY2tMaW1pdCA9IHBMaW1pdChwcmVzZXJ2ZU9yZGVyID8gMSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cblx0dHJ5IHtcblx0XHRhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoZWxlbWVudCA9PiBjaGVja0xpbWl0KGZpbmRlciwgZWxlbWVudCkpKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBFbmRFcnJvcikge1xuXHRcdFx0cmV0dXJuIGVycm9yLnZhbHVlO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9XG59XG4iLCJpbXBvcnQgZnMsIHtwcm9taXNlcyBhcyBmc1Byb21pc2VzfSBmcm9tICdub2RlOmZzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhdGhFeGlzdHMocGF0aCkge1xuXHR0cnkge1xuXHRcdGF3YWl0IGZzUHJvbWlzZXMuYWNjZXNzKHBhdGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhFeGlzdHNTeW5jKHBhdGgpIHtcblx0dHJ5IHtcblx0XHRmcy5hY2Nlc3NTeW5jKHBhdGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cbiIsImltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQge2ZpbmRVcCwgZmluZFVwU3luY30gZnJvbSAnZmluZC11cCc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYWNrYWdlRGlyZWN0b3J5KHtjd2R9ID0ge30pIHtcblx0Y29uc3QgZmlsZVBhdGggPSBhd2FpdCBmaW5kVXAoJ3BhY2thZ2UuanNvbicsIHtjd2R9KTtcblx0cmV0dXJuIGZpbGVQYXRoICYmIHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWNrYWdlRGlyZWN0b3J5U3luYyh7Y3dkfSA9IHt9KSB7XG5cdGNvbnN0IGZpbGVQYXRoID0gZmluZFVwU3luYygncGFja2FnZS5qc29uJywge2N3ZH0pO1xuXHRyZXR1cm4gZmlsZVBhdGggJiYgcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbn1cbiIsIi8qXG5Ib3cgaXQgd29ya3M6XG5gdGhpcy4jaGVhZGAgaXMgYW4gaW5zdGFuY2Ugb2YgYE5vZGVgIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGl0cyBjdXJyZW50IHZhbHVlIGFuZCBuZXN0cyBhbm90aGVyIGluc3RhbmNlIG9mIGBOb2RlYCB0aGF0IGtlZXBzIHRoZSB2YWx1ZSB0aGF0IGNvbWVzIGFmdGVyIGl0LiBXaGVuIGEgdmFsdWUgaXMgcHJvdmlkZWQgdG8gYC5lbnF1ZXVlKClgLCB0aGUgY29kZSBuZWVkcyB0byBpdGVyYXRlIHRocm91Z2ggYHRoaXMuI2hlYWRgLCBnb2luZyBkZWVwZXIgYW5kIGRlZXBlciB0byBmaW5kIHRoZSBsYXN0IHZhbHVlLiBIb3dldmVyLCBpdGVyYXRpbmcgdGhyb3VnaCBldmVyeSBzaW5nbGUgaXRlbSBpcyBzbG93LiBUaGlzIHByb2JsZW0gaXMgc29sdmVkIGJ5IHNhdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgbGFzdCB2YWx1ZSBhcyBgdGhpcy4jdGFpbGAgc28gdGhhdCBpdCBjYW4gcmVmZXJlbmNlIGl0IHRvIGFkZCBhIG5ldyB2YWx1ZS5cbiovXG5cbmNsYXNzIE5vZGUge1xuXHR2YWx1ZTtcblx0bmV4dDtcblxuXHRjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWV1ZSB7XG5cdCNoZWFkO1xuXHQjdGFpbDtcblx0I3NpemU7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHR9XG5cblx0ZW5xdWV1ZSh2YWx1ZSkge1xuXHRcdGNvbnN0IG5vZGUgPSBuZXcgTm9kZSh2YWx1ZSk7XG5cblx0XHRpZiAodGhpcy4jaGVhZCkge1xuXHRcdFx0dGhpcy4jdGFpbC5uZXh0ID0gbm9kZTtcblx0XHRcdHRoaXMuI3RhaWwgPSBub2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiNoZWFkID0gbm9kZTtcblx0XHRcdHRoaXMuI3RhaWwgPSBub2RlO1xuXHRcdH1cblxuXHRcdHRoaXMuI3NpemUrKztcblx0fVxuXG5cdGRlcXVldWUoKSB7XG5cdFx0Y29uc3QgY3VycmVudCA9IHRoaXMuI2hlYWQ7XG5cdFx0aWYgKCFjdXJyZW50KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy4jaGVhZCA9IHRoaXMuI2hlYWQubmV4dDtcblx0XHR0aGlzLiNzaXplLS07XG5cdFx0cmV0dXJuIGN1cnJlbnQudmFsdWU7XG5cdH1cblxuXHRjbGVhcigpIHtcblx0XHR0aGlzLiNoZWFkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuI3RhaWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy4jc2l6ZSA9IDA7XG5cdH1cblxuXHRnZXQgc2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy4jc2l6ZTtcblx0fVxuXG5cdCogW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0bGV0IGN1cnJlbnQgPSB0aGlzLiNoZWFkO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnQpIHtcblx0XHRcdHlpZWxkIGN1cnJlbnQudmFsdWU7XG5cdFx0XHRjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuXHRcdH1cblx0fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9